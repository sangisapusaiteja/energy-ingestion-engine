; =============================================================================
; PGBOUNCER CONFIGURATION — Connection Pooling
; =============================================================================
;
; WHY PGBOUNCER?
;
; Without pooling:
;   - 3 NestJS replicas × 30 connections each = 90 Postgres connections
;   - Scale to 10 replicas = 300 connections, each consuming ~10MB RAM
;   - Postgres fork-per-connection model collapses at ~500 connections
;
; With PgBouncer (transaction pooling):
;   - 300 client connections multiplex into 40 server connections
;   - Postgres sees 40 connections regardless of app replica count
;   - Each batch INSERT holds a server connection for ~5ms, then releases
;   - Connection overhead drops from 3GB to ~400MB
;
; =============================================================================

[databases]
; Map the logical database name to the actual Postgres backend.
; The app connects to PgBouncer on port 6432 as if it were Postgres.
energy_engine = host=postgres port=5432 dbname=energy_engine

[pgbouncer]

; ── Pool Mode ────────────────────────────────────────────────────────────────
; transaction: server connection is assigned per-transaction, then returned.
; This is the sweet spot for our workload:
;   - Ingestion: short transactions (batch INSERT + UPSERT, ~5ms)
;   - Analytics: single-statement reads, no multi-statement transactions
;
; session mode would pin connections (wasteful for short transactions).
; statement mode breaks multi-statement transactions (our ingestion uses them).
pool_mode = transaction

; ── Listen ───────────────────────────────────────────────────────────────────
listen_addr = 0.0.0.0
listen_port = 6432

; ── Authentication ───────────────────────────────────────────────────────────
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/userlist.txt

; ── Startup Parameters ─────────────────────────────────────────────────────
; Ignore startup parameters that PgBouncer does not support (sent by node-pg/TypeORM)
ignore_startup_parameters = extra_float_digits,statement_timeout

; ── Pool Sizing ──────────────────────────────────────────────────────────────

; Max server connections to Postgres per database.
; This is the TOTAL connections Postgres will see from PgBouncer.
; Sized at ~1/3 of Postgres max_connections (120), leaving room for
; direct admin connections and autovacuum workers.
default_pool_size = 40

; Extra connections allowed during traffic spikes.
; If all 40 are busy, allow 10 more temporarily.
reserve_pool_size = 10

; How long to wait before using reserve pool connections.
reserve_pool_timeout = 3

; Max client connections PgBouncer will accept.
; 3 app replicas × 30 connections = 90, with headroom for scaling.
max_client_conn = 400

; Max connections to a single Postgres instance.
; Hard cap — prevents PgBouncer from overwhelming Postgres.
max_db_connections = 50

; ── Timeouts ─────────────────────────────────────────────────────────────────

; Kill server connections idle longer than this.
server_idle_timeout = 300

; Cancel queries running longer than this (seconds).
; Safety net for runaway analytics queries.
query_timeout = 30

; Max time a client waits for a server connection from the pool.
; If the pool is fully utilized for >5s, something is wrong.
client_idle_timeout = 60

; ── Logging ──────────────────────────────────────────────────────────────────
log_connections = 0
log_disconnections = 0

; Log pool stats every 60 seconds for monitoring.
stats_period = 60

; Admin console access (useful for SHOW POOLS, SHOW STATS).
admin_users = postgres
